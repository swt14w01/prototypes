<?xml version="1.0" ?>
<ns2:jqassistant-rules xmlns:ns2="http://www.buschmais.com/jqassistant/core/analysis/rules/schema/v1.0">
  <group id="default">
    <includeConstraint severity="info" refId="modules:UndefinedModules"></includeConstraint>
    <includeConstraint severity="info" refId="modules:ShoppingCartDependencies"></includeConstraint>
    <includeConstraint severity="info" refId="naming:EntitiesInModelPackages"></includeConstraint>
  </group>
  <group id="ejb3:EJB">
    <includeConcept severity="minor" refId="ejb3:StatefulSessionBean"></includeConcept>
    <includeConcept severity="minor" refId="ejb3:Remote"></includeConcept>
    <includeConcept severity="minor" refId="ejb3:StatelessSessionBean"></includeConcept>
    <includeConcept severity="minor" refId="ejb3:Local"></includeConcept>
    <includeConcept severity="minor" refId="ejb3:SingletonBean"></includeConcept>
    <includeConcept severity="minor" refId="ejb3:MessageDrivenBean"></includeConcept>
  </group>
  <group id="testng:TestNG">
    <includeConcept severity="minor" refId="testng:TestClass"></includeConcept>
    <includeConcept severity="minor" refId="testng:BeforeClassMethod"></includeConcept>
    <includeConcept severity="minor" refId="testng:BeforeMethod"></includeConcept>
    <includeConcept severity="minor" refId="testng:BeforeTestMethod"></includeConcept>
    <includeConcept severity="minor" refId="testng:AfterMethod"></includeConcept>
    <includeConcept severity="minor" refId="testng:TestMethod"></includeConcept>
    <includeConcept severity="minor" refId="testng:AfterTestMethod"></includeConcept>
    <includeConcept severity="minor" refId="testng:AfterClassMethod"></includeConcept>
  </group>
  <concept severity="minor" id="cdi:Alternative">
    <description>Labels all types annotated by @javax.enterprise.inject.Alternative with "Cdi" and "Alternative".
        </description>
    <cypher><![CDATA[
            MATCH
              (alternative:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(alternativeType:Type)
            WHERE
              alternativeType.fqn="javax.enterprise.inject.Alternative"
            SET
              alternative:Cdi:Alternative
            RETURN
              alternative AS Alternative
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:Any">
    <description>Labels all elements annotated by "javax.enterprise.inject.Any" with "Cdi" and "Any".
        </description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(anyType:Type)
            WHERE
              anyType.fqn = "javax.enterprise.inject.Any"
            SET
              e:Cdi:Any
            RETURN
              e AS Any
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:ApplicationScoped">
    <description>Labels all beans, fields or methods annotated by @javax.enterprise.context.ApplicationScoped with "Cdi" and "ApplicationScoped".
        </description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(scopeType:Type)
            WHERE
              (e:Type or e:Method or e:Field)
              and scopeType.fqn="javax.enterprise.context.ApplicationScoped"
            SET
              e:Cdi:ApplicationScoped
            RETURN
              e AS ApplicationScopedElement
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:ConversationScoped">
    <description>Labels all beans, fields or methods annotated by @javax.enterprise.context.ConversationScoped with "Cdi" and "ConversationScoped".
        </description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(scopeType:Type)
            WHERE
              (e:Type or e:Method or e:Field)
              and scopeType.fqn="javax.enterprise.context.ConversationScoped"
            SET
              e:Cdi:ConversationScoped
            RETURN
              e AS ConversationScopedElement
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:Decorator">
    <requiresConcept refId="cdi:Delegate"></requiresConcept>
    <description>Labels all types annotated by @javax.decorator.Decorator with "Cdi" and "Decorator".
        </description>
    <cypher><![CDATA[
            MATCH
              (decorator:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(decoratorType:Type)
            WHERE
              decoratorType.fqn="javax.decorator.Decorator"
            SET
              decorator:Cdi:Decorator
            RETURN
              decorator AS Decorator
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:Default">
    <description>Labels all elements annotated by "javax.enterprise.inject.Default" with "Cdi" and "Default".
        </description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(defaultType:Type)
            WHERE
              defaultType.fqn = "javax.enterprise.inject.Default"
            SET
              e:Cdi:Default
            RETURN
              e AS Default
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:Delegate">
    <description>Labels all fields annotated annotated by @javax.decorator.Delegate with "Cdi" and "Delegate".
        </description>
    <cypher><![CDATA[
            MATCH
              (delegate:Field)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(delegateType:Type)
            WHERE
              delegateType.fqn="javax.decorator.Delegate"
            SET
              delegate:Cdi:Delegate
            RETURN
              delegate AS Delegate
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:Dependent">
    <description>Labels all beans, fields or methods annotated by @javax.enterprise.context.Dependent with "Cdi" and "Dependent".</description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(scopeType:Type)
            WHERE
              (e:Type or e:Method or e:Field)
              and scopeType.fqn="javax.enterprise.context.Dependent"
            SET
              e:Cdi:Dependent
            RETURN
              e AS DependentElement
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:Disposes">
    <description>Creates a relation DISPOSES between a parameter and its type if the parameter is annotated by @javax.enterprise.inject.Disposes.
        </description>
    <cypher><![CDATA[
            MATCH
              (:Type)-[:DECLARES]->(disposeMethod:Method)-[:HAS]->(parameter:Parameter),
              (parameter)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(disposesType:Type),
              (parameter)-[:OF_TYPE]->(type)
            WHERE
              disposesType.fqn="javax.enterprise.inject.Disposes"
            CREATE UNIQUE
              (parameter)-[:DISPOSES]->(type)
            RETURN
              disposeMethod AS DisposeMethod
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:EventConsumer">
    <requiresConcept refId="cdi:InjectionPoint"></requiresConcept>
    <description>Labels all beans declaring method that has parameter of type "javax.enterprise.event.Observes" with "Cdi" and "EventConsumer".
        </description>
    <cypher><![CDATA[
            MATCH
              (a:Type)-[:DECLARES]->(member:Method)-[:HAS]->(param:Parameter),
              (param)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(injectType:Type)
            WHERE
              injectType.fqn = "javax.enterprise.event.Observes"
            SET
              a:Cdi:EventConsumer
            RETURN
              DISTINCT a.fqn AS cdiEventConsumer
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:EventProducer">
    <requiresConcept refId="cdi:InjectionPoint"></requiresConcept>
    <description>Labels all beans declaring "InjectionPoint" of type "javax.enterprise.event.Event" with "Cdi" and "EventProducer".
        </description>
    <cypher><![CDATA[
            MATCH
              (a:Type)-[:DECLARES]->(member:Field:Cdi:InjectionPoint),
              (member)-[:OF_TYPE]->(injectType:Type)
            WHERE
              injectType.fqn = "javax.enterprise.event.Event"
            SET
              a:Cdi:EventProducer
            RETURN
              DISTINCT a.fqn AS cdiEventProducers
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:InjectionPoint">
    <description>Labels all fields or methods annotated by @javax.inject.Inject with "Cdi" and "InjectionPoint".</description>
    <cypher><![CDATA[
            MATCH
              (:Type)-[:DECLARES]->(member),
              (member)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(injectType:Type)
            WHERE
              (member:Field or member:Method)
              and injectType.fqn="javax.inject.Inject"
            SET
              member:Cdi:InjectionPoint
            RETURN
              member AS InjectionPoint
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:Named">
    <description>Labels all types or methods annotated by "javax.inject.Named" with "Cdi" and "Named".
        </description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(namedType:Type)
            WHERE
              namedType.fqn = "javax.inject.Named"
            SET
              e:Cdi:Named
            RETURN
              e AS Named
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:New">
    <description>Labels all elements annotated by "javax.enterprise.inject.New" with "Cdi" and "New".
        </description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(newType:Type)
            WHERE
              newType.fqn = "javax.enterprise.inject.New"
            SET
              e:Cdi:New
            RETURN
              e AS New
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:Produces">
    <description>Creates a relation PRODUCES between a field and its type or a method and its return type if the parameter is annotated by
            @javax.enterprise.inject.Disposes.
        </description>
    <cypher><![CDATA[
            MATCH
              (:Type)-[:DECLARES]->(member),
              (member)-[:OF_TYPE|RETURNS]->(type),
              (member)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(producesType:Type)
            WHERE
              (member:Field or member:Method)
              and producesType.fqn="javax.enterprise.inject.Produces"
            CREATE UNIQUE
              (member)-[:PRODUCES]->(type)
            RETURN
              member AS Producer
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:Qualifier">
    <description>Labels all annotation types annotated by @javax.inject.Qualifier with "Cdi" and "Qualifier" and adds the labels "Cdi"
            and "Nonbinding" to
            all non-binding annotation values (i.e. which are annotated by @javax.enterprise.util.Nonbinding).
        </description>
    <cypher><![CDATA[
            MATCH
              (qualifier:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(qualifierType:Type)
            WHERE
              qualifierType.fqn = "javax.inject.Qualifier"
            SET
              qualifier:Cdi:Qualifier
            WITH
              qualifier
            MATCH
              (qualifier)-[:DECLARES]->(attribute:Method),
              (attribute)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(nonbindingType:Type)
            WHERE
              nonbindingType.fqn = "javax.enterprise.util.Nonbinding"
            SET
              attribute:Cdi:Nonbinding
            RETURN
              distinct qualifier AS Qualifier
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:RequestScoped">
    <description>Labels all beans, fields or methods annotated by @javax.enterprise.context.RequestScoped with "Cdi" and "RequestScoped".</description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(scopeType:Type)
            WHERE
              (e:Type or e:Method or e:Field)
              and scopeType.fqn="javax.enterprise.context.RequestScoped"
            SET
              e:Cdi:RequestScoped
            RETURN
              e AS RequestScopedElement
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:SessionScoped">
    <description>Labels all beans, fields or methods annotated by @javax.enterprise.context.SessionScoped with "Cdi" and "SessionScoped".</description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(scopeType:Type)
            WHERE
              (e:Type or e:Method or e:Field)
              and scopeType.fqn="javax.enterprise.context.SessionScoped"
            SET
              e:Cdi:SessionScoped
            RETURN
              e AS SessionScopedElement
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:SingletonScoped">
    <description>Labels all beans annotated by @javax.inject.Singleton with "Cdi" and "SingletonScoped".
        </description>
    <cypher><![CDATA[
            MATCH
              (t:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn = "javax.inject.Singleton"
            SET
              t:Cdi:SingletonScoped
            RETURN
              t AS cdiSingleton
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:Specializes">
    <description>Labels all types and methods annotated by @javax.enterprise.inject.Specializes with "Cdi" and "Specializes".
        </description>
    <cypher><![CDATA[
            MATCH
              (specializes)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(specializesType:Type)
            WHERE
              (specializes:Type or specializes:Method)
              and specializesType.fqn="javax.enterprise.inject.Specializes"
            SET
              specializes:Cdi:Specializes
            RETURN
              specializes AS Specialization
        ]]></cypher>
  </concept>
  <concept severity="minor" id="cdi:Stereotype">
    <description>Labels all annotation types annotated by @javax.enterprise.inject.Stereotype with "Cdi" and "Stereotype".
        </description>
    <cypher><![CDATA[
            MATCH
              (stereotype:Type:Annotation)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(stereotypeType:Type)
            WHERE
              stereotypeType.fqn="javax.enterprise.inject.Stereotype"
            SET
              stereotype:Cdi:Stereotype
            RETURN
              stereotype AS Stereotype
        ]]></cypher>
  </concept>
  <concept severity="minor" id="decorator:Decorator">
    <requiresConcept refId="decorator:Delegate"></requiresConcept>
    <description>Labels all types annotated by @javax.decorator.Decorator with "Decorator".
        </description>
    <cypher><![CDATA[
            MATCH
              (decorator:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(decoratorType:Type)
            WHERE
              decoratorType.fqn="javax.decorator.Decorator"
            SET
              decorator:Decorator
            RETURN
              decorator AS Decorator
        ]]></cypher>
  </concept>
  <concept severity="minor" id="decorator:Delegate">
    <description>Labels all fields annotated annotated by @javax.decorator.Delegate with "Decorator" and "Delegate".
        </description>
    <cypher><![CDATA[
            MATCH
              (delegate:Field)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(delegateType:Type)
            WHERE
              delegateType.fqn="javax.decorator.Delegate"
            SET
              delegate:Decorator:Delegate
            RETURN
              delegate AS Delegate
        ]]></cypher>
  </concept>
  <concept severity="minor" id="dependency:Artifact">
    <description>Creates a DEPENDS_ON relationship between artifacts if there are type dependencies between them.
        </description>
    <cypher><![CDATA[
            MATCH
                (a1:Artifact)-[:REQUIRES]->(t1:Type),
                (a2:Artifact)-[:CONTAINS]-(t2:Type)
            WHERE
                t1.fqn=t2.fqn
            CREATE UNIQUE
                (a1)-[:DEPENDS_ON]->(a2)
            RETURN
                a1 AS Artifact, COLLECT(DISTINCT a2.name) AS Dependencies
        ]]></cypher>
  </concept>
  <concept severity="minor" id="dependency:Package">
    <description>Creates a DEPENDS_ON relationship between a packages if there are type dependencies between them.
        </description>
    <cypher><![CDATA[
            MATCH
                (p1:Package)-[:CONTAINS]->(t1:Type)-[:DEPENDS_ON]->(t2:Type)<-[:CONTAINS]-(p2:Package)
            WHERE
                p1<>p2
            CREATE UNIQUE
                (p1)-[:DEPENDS_ON]->(p2)
            RETURN
                p1 AS package, COUNT(DISTINCT p2) AS PackageDependencyCount
        ]]></cypher>
  </concept>
  <concept severity="minor" id="ejb3:Local">
    <description>Labels all types annotated with @javax.ejb.Local with "Ejb" and "Local".</description>
    <cypher><![CDATA[
            MATCH (t:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE a.fqn="javax.ejb.Local"
            SET t:Ejb:Local
            RETURN t AS LocalBean
        ]]></cypher>
  </concept>
  <concept severity="minor" id="ejb3:MessageDrivenBean">
    <description>Labels all types annotated with @javax.ejb.MessageDriven with "Ejb" and "MessageDriven".</description>
    <cypher><![CDATA[
            MATCH (t:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE a.fqn="javax.ejb.MessageDriven"
            SET t:Ejb:MessageDriven
            RETURN t AS MessageDrivenBean
        ]]></cypher>
  </concept>
  <concept severity="minor" id="ejb3:Remote">
    <description>Labels all types annotated with @javax.ejb.Remote with "Ejb" and "Remote".</description>
    <cypher><![CDATA[
            MATCH (t:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE a.fqn="javax.ejb.Remote"
            SET t:Ejb:Remote
            RETURN t AS RemoteBean
        ]]></cypher>
  </concept>
  <concept severity="minor" id="ejb3:SingletonBean">
    <description>Labels all classes annotated with @javax.ejb.Singleton with "Ejb" and "Singleton".</description>
    <cypher><![CDATA[
            MATCH (t:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE a.fqn="javax.ejb.Singleton"
            SET t:Ejb:Singleton
            RETURN t AS SingletonEjb
        ]]></cypher>
  </concept>
  <concept severity="minor" id="ejb3:StatefulSessionBean">
    <description>Labels all types annotated with @javax.ejb.Stateful with "Ejb" and "Stateful".</description>
    <cypher><![CDATA[
            MATCH (t:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE a.fqn="javax.ejb.Stateful"
            SET t:Ejb:Stateful
            RETURN t AS StatefulEjb
        ]]></cypher>
  </concept>
  <concept severity="minor" id="ejb3:StatelessSessionBean">
    <description>Labels all types annotated with @javax.ejb.Stateless with "Ejb" and "Stateless".</description>
    <cypher><![CDATA[
            MATCH (t:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE a.fqn="javax.ejb.Stateless"
            SET t:Ejb:Stateless
            RETURN t AS StatelessEjb
        ]]></cypher>
  </concept>
  <concept severity="minor" id="interceptor:Binding">
    <description>Labels all annotations annotated by "javax.interceptor.InterceptorBinding" with "Interceptor" and "Binding".
        </description>
    <cypher><![CDATA[
            MATCH
              (binding:Type:Annotation)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(bindingType:Type)
            WHERE
              bindingType.fqn = "javax.interceptor.InterceptorBinding"
            SET
              binding:Interceptor:Binding
            RETURN
              binding AS InterceptorBinding
        ]]></cypher>
  </concept>
  <concept severity="minor" id="interceptor:Interceptor">
    <description>Labels all classes annotated by "javax.interceptor.Interceptor" with "Interceptor".
        </description>
    <cypher><![CDATA[
            MATCH
              (interceptor:Type:Class)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(interceptorType:Type)
            WHERE
              interceptorType.fqn = "javax.interceptor.Interceptor"
            SET
              interceptor:Interceptor
            RETURN
              interceptor AS Interceptor
        ]]></cypher>
  </concept>
  <concept severity="minor" id="java8:DefaultMethod">
    <description>Labels default methods of interfaces with "Default".</description>
    <cypher><![CDATA[
            MATCH
              (type:Type:Interface)-[:DECLARES]->(defaultMethod:Method)
            WHERE NOT
              has(defaultMethod.abstract)
            SET
              defaultMethod:Default
            RETURN
              defaultMethod AS DefaultMethod, type AS Interface
        ]]></cypher>
  </concept>
  <concept severity="minor" id="java8:FunctionalInterface">
    <description>Labels functional interfaces (i.e. to be used as lambda expressions) with "FunctionalInterface".</description>
    <cypher><![CDATA[
            MATCH
              (functionalInterface:Interface)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(functionalInterfaceType)
            WHERE
              functionalInterfaceType.fqn = 'java.lang.FunctionalInterface'
            SET
              functionalInterface:FunctionalInterface
            RETURN
              functionalInterface AS FunctionalInterface
        ]]></cypher>
  </concept>
  <concept severity="minor" id="java:AnonymousInnerType">
    <requiresConcept refId="java:InnerType"></requiresConcept>
    <description>Sets a label "Anonymous" on anonymous inner types, i.e. types without a name.</description>
    <cypher>
            MATCH
              (innerType:Inner:Type)
            WHERE
              innerType.name =~ ".*\\$[0-9]*"
            SET
              innerType:Anonymous
            RETURN
              innerType AS AnonymousInnerType
        </cypher>
  </concept>
  <concept severity="minor" id="java:Deprecated">
    <description>Labels all nodes representing deprecated elements (types, fields, methods, packages or parameters) with "Deprecated".</description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(dt:Type)
            WHERE
              dt.fqn='java.lang.Deprecated'
            SET
              e:Deprecated
            RETURN
              e AS DeprecatedElement
        ]]></cypher>
  </concept>
  <concept severity="minor" id="java:Error">
    <description>Labels types deriving from java.lang.Error as "Error".</description>
    <cypher><![CDATA[
            MATCH
              (throwable)-[:EXTENDS*]->(t:Type)
            WHERE
              t.fqn = 'java.lang.Error'
            SET
              throwable:Error
            RETURN
              throwable AS Error
        ]]></cypher>
  </concept>
  <concept severity="minor" id="java:Exception">
    <description>Labels types deriving from java.lang.Exception as "Exception".</description>
    <cypher><![CDATA[
            MATCH
              (exception)-[:EXTENDS*]->(t:Type)
            WHERE
              t.fqn = 'java.lang.Exception'
            SET
              exception:Exception
            RETURN
              exception AS Exception
        ]]></cypher>
  </concept>
  <concept severity="minor" id="java:InnerType">
    <description>Sets a label "Inner" on inner types.</description>
    <cypher><![CDATA[
            MATCH
              (:Type)-[:DECLARES]->(innerType:Type)
            SET
              innerType:Inner
            RETURN
              innerType AS InnerType
        ]]></cypher>
  </concept>
  <concept severity="minor" id="java:InvokesOverriddenMethod">
    <requiresConcept refId="java:MethodOverrides"></requiresConcept>
    <requiresConcept refId="java:TypeAssignableFrom"></requiresConcept>
    <description>Propagates INVOKES relationships to methods which implement or override the invoked method.</description>
    <cypher><![CDATA[
            MATCH
              (method:Method)-[:INVOKES]->(invokedMethod:Method),
              (overridingMethod:Method)-[:OVERRIDES]->(invokedMethod)
            CREATE UNIQUE
              (method)-[r:INVOKES]->(overridingMethod)
            RETURN r AS OverridingInvocation
        ]]></cypher>
  </concept>
  <concept severity="minor" id="java:MethodOverloads">
    <description>Creates a relationship OVERLOADS between two "Method" labeled nodes if one method overloads another one from the same type (i.e. the
            methods
            have the same name but not the same signature).
        </description>
    <cypher><![CDATA[
            MATCH
              (type:Type)-[:DECLARES]->(method:Method),
              (type)-[:DECLARES]->(otherMethod:Method)
            WHERE
              method <> otherMethod
              AND method.name = otherMethod.name
              AND method.signature <> otherMethod.signature
            CREATE UNIQUE
                (method)-[:OVERLOADS]->(otherMethod)
            RETURN method AS OverloadedMethod, type AS DeclaringType
        ]]></cypher>
  </concept>
  <concept severity="minor" id="java:MethodOverrides">
    <requiresConcept refId="java:TypeAssignableFrom"></requiresConcept>
    <description>Creates a relationship OVERRIDES between two "Method" labeled nodes if one method overrides another one from a super type (i.e. the methods
            have the same signature).
        </description>
    <cypher><![CDATA[
            MATCH
              (type:Type)-[:DECLARES]->(method:Method),
              (superType:Type)-[:DECLARES]->(otherMethod:Method),
              (superType)-[:ASSIGNABLE_FROM]->(type)
            WHERE
              method.name = otherMethod.name
              AND method.signature = otherMethod.signature
              AND method.visibility <> 'private'
            CREATE UNIQUE
              (method)-[:OVERRIDES]->(otherMethod)
            RETURN method AS OverriddenMethod, type AS DeclaringType, superType AS SuperType
        ]]></cypher>
  </concept>
  <concept severity="minor" id="java:RuntimeException">
    <description>Labels types deriving from java.lang.RuntimeException as "RuntimeException".</description>
    <cypher><![CDATA[
            MATCH
              (runtimeException)-[:EXTENDS*]->(t:Type)
            WHERE
              t.fqn = 'java.lang.RuntimeException'
            SET
              runtimeException:RuntimeException
            RETURN
              runtimeException AS RuntimeException
        ]]></cypher>

  </concept>
  <concept severity="minor" id="java:Throwable">
    <description>Labels types deriving from java.lang.Throwable as "Throwable".</description>
    <cypher><![CDATA[
            MATCH
              (throwable)-[:EXTENDS*]->(t:Type)
            WHERE
              t.fqn = 'java.lang.Throwable'
            SET
              throwable:Throwable
            RETURN
              throwable AS Throwable
        ]]></cypher>
  </concept>
  <concept severity="minor" id="java:TypeAssignableFrom">
    <description>Creates a relationship ASSIGNABLE_FROM between two "Type" labeled nodes if one type is assignable from the other (i.e. a super class or
            interface).
        </description>
    <cypher><![CDATA[
            MATCH
              (type:Type)
            CREATE UNIQUE
              (type)-[:ASSIGNABLE_FROM]->(type)
            WITH
              type
            MATCH
              (type)-[:IMPLEMENTS|EXTENDS*]->(superType:Type)
            CREATE UNIQUE
              (superType)-[:ASSIGNABLE_FROM]->(type)
            RETURN type AS AssignableType, superType AS AssignableFrom
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:ContextProvider">
    <description>Finds classes that implement "javax.ws.rs.ext.ContextResolver" and labels them with 'JaxRS' and 'ContextProvider'
		</description>
    <cypher><![CDATA[
            MATCH 
              (c:Type:Class)-[:IMPLEMENTS]->(a:Type)
            WHERE 
              a.fqn = "javax.ws.rs.ext.ContextResolver"
            SET 
              c:JaxRS:ContextProvider
            RETURN 
              DISTINCT c AS ContextProvider
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:DeleteResourceMethod">
    <requiresConcept refId="jaxrs:ResourceMethod"></requiresConcept>
    <description>Finds resource methods annotated with "@javax.ws.rs.DELETE" and labels them with 'DeleteResourceMethod'. </description>
    <cypher><![CDATA[
            MATCH
              (m:JaxRS:ResourceMethod)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(a:JaxRS:RequestMethodDesignator)
            WHERE
              a.fqn = "javax.ws.rs.DELETE"
            SET
              m:DeleteResourceMethod
            RETURN
              m AS DeleteMethod
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:EntityProvider">
    <description>Finds classes that implement "javax.ws.rs.ext.MessageBodyReader" 
		or "javax.ws.rs.ext.MessageBodyWriter" and labels them with 'JaxRS' and 'EntityProvider'
		</description>
    <cypher><![CDATA[
            MATCH 
              (c:Type:Class)-[:IMPLEMENTS]->(a:Type)
            WHERE 
              a.fqn IN ["javax.ws.rs.ext.MessageBodyReader", "javax.ws.rs.ext.MessageBodyWriter"]
            SET 
              c:JaxRS:EntityProvider
            RETURN 
              DISTINCT c AS EntityProvider
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:ExceptionMappingProvider">
    <description>Finds classes that implement "javax.ws.rs.ext.ExceptionMapper" and labels them with 'JaxRS' and 'ExceptionMappingProvider'
		</description>
    <cypher><![CDATA[
            MATCH 
              (c:Type:Class)-[:IMPLEMENTS]->(a:Type)
            WHERE 
              a.fqn = "javax.ws.rs.ext.ExceptionMapper"
            SET 
              c:JaxRS:ExceptionMappingProvider
            RETURN 
              DISTINCT c AS ExceptionMappingProvider
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:GetResourceMethod">
    <requiresConcept refId="jaxrs:ResourceMethod"></requiresConcept>
    <description>Finds resource methods annotated with "@javax.ws.rs.GET" and labels them with 'GetResourceMethod'. </description>
    <cypher><![CDATA[
            MATCH
              (m:JaxRS:ResourceMethod)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(a:JaxRS:RequestMethodDesignator)
            WHERE
              a.fqn = "javax.ws.rs.GET"
            SET
              m:GetResourceMethod
            RETURN
              m AS GetMethod
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:HeadResourceMethod">
    <requiresConcept refId="jaxrs:ResourceMethod"></requiresConcept>
    <description>Finds resource methods annotated with "@javax.ws.rs.HEAD" and labels them with 'HeadResourceMethod'. </description>
    <cypher><![CDATA[
            MATCH
              (m:JaxRS:ResourceMethod)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(a:JaxRS:RequestMethodDesignator)
            WHERE
              a.fqn = "javax.ws.rs.HEAD"
            SET
              m:HeadResourceMethod
            RETURN
              m AS HeadMethod
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:OptionsResourceMethod">
    <requiresConcept refId="jaxrs:ResourceMethod"></requiresConcept>
    <description>Finds resource methods annotated with "@javax.ws.rs.OPTIONS" and labels them with 'OptionsResourceMethod'. </description>
    <cypher><![CDATA[
            MATCH
              (m:JaxRS:ResourceMethod)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(a:JaxRS:RequestMethodDesignator)
            WHERE
              a.fqn = "javax.ws.rs.OPTIONS"
            SET
              m:OptionsResourceMethod
            RETURN
              m AS OptionsMethod
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:PostResourceMethod">
    <requiresConcept refId="jaxrs:ResourceMethod"></requiresConcept>
    <description>Finds resource methods annotated with "@javax.ws.rs.POST" and labels them with 'PostResourceMethod'. </description>
    <cypher><![CDATA[
            MATCH
              (m:JaxRS:ResourceMethod)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(a:JaxRS:RequestMethodDesignator)
            WHERE
              a.fqn = "javax.ws.rs.POST"
            SET
              m:PostResourceMethod
            RETURN
              m AS PostMethod
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:PutResourceMethod">
    <requiresConcept refId="jaxrs:ResourceMethod"></requiresConcept>
    <description>Finds resource methods annotated with "@javax.ws.rs.PUT" and labels them with 'PutResourceMethod'. </description>
    <cypher><![CDATA[
            MATCH
              (m:JaxRS:ResourceMethod)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(a:JaxRS:RequestMethodDesignator)
            WHERE
              a.fqn = "javax.ws.rs.PUT"
            SET
              m:PutResourceMethod
            RETURN
              m AS PutMethod
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:RequestMethodDesignator">
    <description>Finds request method designator annotations (i.e. @GET, @POST, @PUT, @DELETE, @HEAD, @OPTIONS) and labels them with 'JaxRS' and 'RequestMethodDesignator'
		</description>
    <cypher>
            MATCH 
              (a:Type)
            WHERE
              a.fqn IN ["javax.ws.rs.GET", "javax.ws.rs.POST", "javax.ws.rs.PUT", "javax.ws.rs.DELETE", "javax.ws.rs.HEAD", "javax.ws.rs.OPTIONS"]
            SET
              a:JaxRS:RequestMethodDesignator
            RETURN
              a AS RequestMethodDesignator
        </cypher>
  </concept>
  <concept severity="minor" id="jaxrs:Resource">
    <requiresConcept refId="jaxrs:RequestMethodDesignator"></requiresConcept>
    <description>Finds classes or interfaces with atleast one method annotated with "@javax.ws.rs.Path" or with request method designator 
		(i.e. @GET, @POST, @PUT, @DELETE, @HEAD, @OPTIONS) and labels them with 'JaxRS' and 'Resource'.
		</description>
    <cypher><![CDATA[
            MATCH
              (t:Type)-[:DECLARES]->(m:Method)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(a:Type)
            WHERE
              (a:JaxRS:RequestMethodDesignator OR a.fqn="javax.ws.rs.Path")
            AND
              (t:Class OR t:Interface)
            SET
              t:JaxRS:Resource
            RETURN
              DISTINCT t AS RestResource
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:ResourceMethod">
    <requiresConcept refId="jaxrs:Resource"></requiresConcept>
    <description>Finds methods that belong to resource class or interface and annotated with request method designator 
		(i.e. @GET, @POST, @PUT, @DELETE, @HEAD, @OPTIONS) and labels them with 'JaxRS' and 'ResourceMethod'.
		</description>
    <cypher><![CDATA[
            MATCH
              (c:JaxRS:Resource)-[:DECLARES]->(m:Method)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(a:JaxRS:RequestMethodDesignator)
            SET
              m:JaxRS:ResourceMethod
            RETURN
              m AS ResourceMethod
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jaxrs:SubResourceLocator">
    <requiresConcept refId="jaxrs:RequestMethodDesignator"></requiresConcept>
    <description>Finds classes or interfaces with method annotated with "@javax.ws.rs.Path" but no request method designator 
		and no entity parameters and labels the methods with 'JaxRS' and 'SubResourceLocator'.
		</description>
    <cypher><![CDATA[
            MATCH
              (t:Type)-[:DECLARES]->(m:Method)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn = "javax.ws.rs.Path"
            AND
              (t:Class OR t:Interface)
            AND
              NOT (m)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(:JaxRS:RequestMethodDesignator)
            AND
              (m)-[:HAS]->(:Parameter)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(:Type)
            SET
              m:JaxRS:SubResourceLocator
            RETURN
              DISTINCT m AS RestSubResourceLocator
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jpa2:Embeddable">
    <description>Labels all types annotated with @javax.persistence.Embeddable with "Jpa" and "Embeddable".</description>
    <cypher><![CDATA[
            MATCH
              (t:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="javax.persistence.Embeddable"
            SET
              t:Jpa:Embeddable
            RETURN
              t AS JpaEmbeddable
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jpa2:Embedded">
    <description>Labels all fields or methods annotated with @javax.persistence.Embedded with "Jpa" and "Embedded".</description>
    <cypher><![CDATA[
            MATCH
              (t:Type)-[:DECLARES]->(member),
              (member)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              (member:Field or member:Method)
              and a.fqn="javax.persistence.Embedded"
            SET
              member:Jpa:Embedded
            RETURN
              member AS JpaEmbedded
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jpa2:EmbeddedId">
    <description>Labels all fields or methods annotated with @javax.persistence.EmbeddedId with "Jpa" and "Embedded".</description>
    <cypher><![CDATA[
            MATCH
              (t:Type)-[:DECLARES]->(member),
              (member)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              (member:Field or member:Method)
              and a.fqn="javax.persistence.EmbeddedId"
            SET
              member:Jpa:EmbeddedId
            RETURN
              member AS EmbeddedId
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jpa2:Entity">
    <description>Labels all types annotated with @javax.persistence.Entity with "Jpa" and "Entity".</description>
    <cypher><![CDATA[
            MATCH
              (t:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="javax.persistence.Entity"
            SET
              t:Jpa:Entity
            RETURN
              t AS JpaEntity
        ]]></cypher>
  </concept>
  <concept severity="minor" id="jpa2:NamedQuery">
    <requiresConcept refId="jpa2:Entity"></requiresConcept>
    <description>Creates a node labeled with "Jpa" and "NamedQuery" for each @NamedQuery defined for an entity. Furthermore a relation DEFINES is created
            between the entity and the named query.
        </description>
    <cypher><![CDATA[
            MATCH
              (entity:Jpa:Entity)-[:ANNOTATED_BY]->(namedQueries)-[:OF_TYPE]->(namedQueriesType:Type),
              (namedQueries)-[:HAS]->(:Value:Array)-[:CONTAINS]->(namedQuery:Value:Annotation)-[:OF_TYPE]->(namedQueryType:Type),
              (namedQuery)-[:HAS]->(nameAttribute:Value),
              (namedQuery)-[:HAS]->(queryAttribute:Value)
            WHERE
              namedQueriesType.fqn = 'javax.persistence.NamedQueries'
              and namedQueryType.fqn = 'javax.persistence.NamedQuery'
              and nameAttribute.name = 'name'
              and queryAttribute.name = 'query'
            CREATE UNIQUE
              (entity)-[:DEFINES]->(n:Jpa:NamedQuery {name:nameAttribute.value, query:queryAttribute.value})
            RETURN
              entity AS Entity, n.name AS Name, n.query AS Query
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit3:SetUpMethod">
    <requiresConcept refId="junit3:TestClass"></requiresConcept>
    <description>Labels all setUp methods declared by a test class with "SetUp" and "Junit3".</description>
    <cypher><![CDATA[
            MATCH
              (c:Class:Test:Junit3)-[:DECLARES]->(m:Method)
            WHERE
              m.signature = "void setUp()"
            SET
              m:SetUp:Junit3
            RETURN
              m AS SetUpMethod, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit3:TearDownMethod">
    <requiresConcept refId="junit3:TestClass"></requiresConcept>
    <description>Labels all tearDown methods declared by a test class with "TearDown" and "Junit3".</description>
    <cypher><![CDATA[
            MATCH
              (c:Class:Test:Junit3)-[:DECLARES]->(m:Method)
            WHERE
              m.signature = "void tearDown()"
            SET
              m:TearDown:Junit3
            RETURN
              m AS TearDownMethod, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit3:TestClass">
    <description>Labels all non-abstract classes extending from junit.framework.TestCase "Test" and "Junit3".</description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:EXTENDS*]->(testCaseType:Type)
            WHERE
              testCaseType.fqn = "junit.framework.TestCase"
            SET
              c:Test:Junit3
            RETURN
              c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit3:TestMethod">
    <requiresConcept refId="junit3:TestClass"></requiresConcept>
    <description>Labels all test methods declared by a test class with "Test" and "Junit3".
        </description>
    <cypher><![CDATA[
            MATCH
              (c:Class:Test:Junit3)-[:DECLARES]->(m:Method)
            WHERE
              m.signature =~ "void test.*\\(.*\\)"
            SET
              m:Test:Junit3
            RETURN
              m AS Test, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit4:AfterClassMethod">
    <description>Labels all methods annotated by "@org.junit.AfterClass" with "Junit4" and "AfterClass".
        </description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method),
              (m:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.junit.AfterClass"
            SET
              m:Junit4:AfterClass
            RETURN
              m AS AfterClassMethod, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit4:AfterMethod">
    <description>Labels all methods annotated by "@org.junit.After" with "Junit4" and "After".</description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method),
              (m:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.junit.After"
            SET
              m:Junit4:After
            RETURN
              m AS AfterMethod, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit4:AssertMethod">
    <description>Labels all assertion methods declared by org.junit.Assert with "Junit4" and "Assert".</description>
    <cypher><![CDATA[
            MATCH
              (assertType:Type)-[:DECLARES]->(assertMethod)
            WHERE
              assertType.fqn = 'org.junit.Assert'
              and assertMethod.signature =~ 'void assert.*'
            SET
              assertMethod:Junit4:Assert
            RETURN
              assertMethod
            ]]></cypher>
  </concept>
  <concept severity="minor" id="junit4:BeforeClassMethod">
    <description>Labels all methods annotated by "@org.junit.BeforeClass" with "Junit4" and "BeforeClass".
        </description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method),
              (m:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.junit.BeforeClass"
            SET
              m:Junit4:BeforeClass
            RETURN
              m AS BeforeClassMethod, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit4:BeforeMethod">
    <description>Labels all methods annotated by "@org.junit.Before" with "Junit4" and "Before".</description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method),
              (m:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.junit.Before"
            SET
              m:Junit4:Before
            RETURN
              m AS BeforeMethod, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit4:IgnoreTestClassOrMethod">
    <description>Labels all classes or methods annotated with "@org.junit.Ignore" with "Junit4" and "Ignore".
        </description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.junit.Ignore"
            SET
              e:Junit4:Ignore
            RETURN
              e AS IgnoredElement
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit4:TestCaseImplementedByMethod">
    <description>Creates a relation IMPLEMENTED_BY between all test cases from test reports and their implementing
            methods.
        </description>
    <cypher><![CDATA[
            MATCH
              (testcase:TestCase)
            WITH
              testcase
            MATCH
              (testclass:Type)-[:DECLARES]->(testmethod:Method)
            WHERE
              testclass.fqn = testcase.className
              and testmethod.name = testcase.name
            CREATE UNIQUE
              (testcase)-[:IMPLEMENTED_BY]->(testmethod)
            RETURN
              testcase AS TestCase
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit4:TestClass">
    <requiresConcept refId="junit4:TestMethod"></requiresConcept>
    <description>Labels all classes containing test methods with "Test" and "Junit4".</description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method:Junit4:Test)
            SET
              c:Test:Junit4
            RETURN
              c AS TestClass, COLLECT(m) AS TestMethods
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit4:TestClassOrMethod">
    <requiresConcept refId="junit4:TestMethod"></requiresConcept>
    <requiresConcept refId="junit4:TestClass"></requiresConcept>
    <description>Finds test methods (i.e. annotated with "@org.junit.Test") and labels them and their containing
            classes with "Test" and "Junit4".
        </description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method:Junit4:Test)
            RETURN
              c AS TestClass, COLLECT(m) AS TestMethods
        ]]></cypher>
  </concept>
  <concept severity="minor" id="junit4:TestMethod">
    <description>Finds all test methods (i.e. annotated with "@org.junit.Test") and labels them with "Test" and
            "Junit4".
        </description>
    <cypher><![CDATA[
            MATCH
              (m:Method)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.junit.Test"
            SET
              m:Test:Junit4
            RETURN
              m AS Test
        ]]></cypher>
  </concept>
  <concept severity="minor" id="metric:Top10FieldsPerType">
    <description>Returns the top 10 types regarding to the number of declared fields.</description>
    <cypher><![CDATA[
            MATCH
                (t:Type:File)-[:DECLARES]->(f:Field)
            RETURN
                t.fqn as Type, COUNT(f) as FieldCount
            ORDER BY
                FieldCount DESC
            LIMIT 10
        ]]></cypher>
  </concept>
  <concept severity="minor" id="metric:Top10MethodsPerType">
    <description>Returns the top 10 types regarding to the number of declared methods (including constructors).
        </description>
    <cypher><![CDATA[
            MATCH
                (t:Type:File)-[:DECLARES]->(m:Method)
            RETURN
                t.fqn as Type, COUNT(m) as MethodCount
            ORDER BY
                MethodCount DESC
            LIMIT 10
        ]]></cypher>
  </concept>
  <concept severity="minor" id="metric:Top10TypeFanIn">
    <description>Returns the top 10 types regarding the number of other types depending on them.</description>
    <cypher><![CDATA[
            MATCH
                (t:Type:File)<-[:DEPENDS_ON]-(dependent:Type)
            RETURN
                t.fqn as Type, COUNT(dependent) as Dependents
            ORDER BY
                Dependents DESC
            LIMIT 10
        ]]></cypher>
  </concept>
  <concept severity="minor" id="metric:Top10TypeFanOut">
    <description>Returns the top 10 types regarding the number of other types they depend on.</description>
    <cypher><![CDATA[
            MATCH
                (t:Type:File)-[:DEPENDS_ON]->(dependency:Type)
            RETURN
                t.fqn as Type, COUNT(dependency) as Dependencies
            ORDER BY
                Dependencies DESC
            LIMIT 10
        ]]></cypher>
  </concept>
  <concept severity="minor" id="metric:Top10TypesPerArtifact">
    <description>Returns the top 10 artifacts regarding the number of contained types.</description>
    <cypher><![CDATA[
            MATCH
                (a:Artifact:File)-[:CONTAINS]->(t:Type:File)
            RETURN
                a.fqn as Artifact, COUNT(t) as Types
            ORDER BY
                Types DESC
            LIMIT 10
        ]]></cypher>
  </concept>
  <concept severity="minor" id="metric:Top10TypesPerPackage">
    <description>Returns the top 10 packages regarding the number of contained types.</description>
    <cypher><![CDATA[
            MATCH
                (p:Package:File)-[:CONTAINS]->(t:Type:File)
            RETURN
                p.fqn as Package, COUNT(t) as Types
            ORDER BY
                Types DESC
            LIMIT 10
        ]]></cypher>
  </concept>
  <concept severity="minor" id="modules:DataImport">
    <description>Labels the package "org.jqassistant.demo.dataimport" as "Module" and "DataImport".</description>
    <cypher>
          MATCH
            (m:Package)
          WHERE
			m.fqn="org.jqassistant.demo.dataimport"
	      SET
	        m:Module:DataImport
          RETURN
            m.fqn as Module
        </cypher>
  </concept>
  <concept severity="minor" id="modules:DefinedModules">
    <requiresConcept refId="modules:DataImport"></requiresConcept>
    <requiresConcept refId="modules:ShoppingCart"></requiresConcept>
    <requiresConcept refId="modules:UserManagement"></requiresConcept>
    <description>Returns all defined modules.</description>
    <cypher>
          MATCH
            (m:Package:Module)
          RETURN
            m.fqn as Module
        </cypher>
  </concept>
  <concept severity="minor" id="modules:ShoppingCart">
    <description>Labels the package "org.jqassistant.demo.shoppingcart" as "Module" and "ShoppingCart".</description>
    <cypher>
          MATCH
            (m:Package)
          WHERE
			m.fqn="org.jqassistant.demo.shoppingcart"
	      SET
	        m:Module:ShoppingCart
          RETURN
            m.fqn as Module
        </cypher>
  </concept>
  <concept severity="minor" id="modules:UserManagement">
    <description>Labels the package "org.jqassistant.demo.usermanagement" as "Module" and "UserManagement".</description>
    <cypher>
          MATCH
            (m:Package)
          WHERE
			m.fqn="org.jqassistant.demo.usermanagement"
	      SET
	        m:Module:UserManagement
          RETURN
            m.fqn as Module
        </cypher>
  </concept>
  <concept severity="minor" id="osgi-bundle:Activator">
    <requiresConcept refId="osgi-bundle:Bundle"></requiresConcept>
    <description>Creates an ACTIVATES relation between a class and the bundle artifact if the class is declared as
            "Bundle-Activator" in the bundle
            manifest.
        </description>
    <cypher><![CDATA[
            match
              (bundle:Osgi:Bundle)-[:CONTAINS]->(manifest:File:Manifest),
              (manifest)-[:DECLARES]->(section:ManifestSection),
              (section)-[:HAS]->(entry:ManifestEntry),
              (bundle)-[:CONTAINS]->(activator:Class)
            where
              entry.name = "Bundle-Activator"
              and entry.value = activator.fqn
            create unique
              (activator)-[:ACTIVATES]->(bundle)
            return
              activator as Activator, bundle as Bundle
        ]]></cypher>
  </concept>
  <concept severity="minor" id="osgi-bundle:Bundle">
    <description>Labels all artifacts with a manifest declaring a bundle name as "Osgi" and "Bundle" and adds the
            properties "bundleSymbolicName" and "bundleVersion".
        </description>
    <cypher><![CDATA[
            MATCH
              (bundle:Artifact)-[:CONTAINS]->(manifest:Manifest:File),
              (manifest)-[DECLARES]->(section:ManifestSection),
              (section)-[:HAS]->(nameEntry:ManifestEntry),
              (section)-[:HAS]->(versionEntry:ManifestEntry)
            WHERE
              nameEntry.name = "Bundle-SymbolicName"
              AND versionEntry.name = "Bundle-Version"
            SET
              bundle:Osgi:Bundle,
              bundle.bundleSymbolicName = nameEntry.value,
              bundle.bundleVersion = versionEntry.value
            RETURN
              bundle as Bundle, bundle.bundleSymbolicName as BundleSymbolicName, bundle.bundleVersion as BundleVersion
        ]]></cypher>
  </concept>
  <concept severity="minor" id="osgi-bundle:ExportPackage">
    <requiresConcept refId="osgi-bundle:Bundle"></requiresConcept>
    <description>Creates an EXPORTS relation from a bundle artifact to all packages which are declared as
            "Export-Package" in the bundle manifest.
        </description>
    <cypher><![CDATA[
            match
             (bundle:Osgi:Bundle)-[:CONTAINS]->(package:Package)
            with
              bundle, package, "(^|.*,)\\s*"+ replace(package.fqn, ".", "\\.")+"\\s*((;|,).*|$)" as pattern
            match
              (bundle)-[:CONTAINS]->(manifest:File:Manifest),
              (manifest)-[:DECLARES]->(section:ManifestSection),
              (section)-[:HAS]->(entry:ManifestEntry)
            where
              entry.name = "Export-Package"
              AND entry.value=~ pattern
            create unique
              (bundle)-[:EXPORTS]->(package)
            return
              bundle as Bundle, collect(package) as ExportedPackages
        ]]></cypher>
  </concept>
  <concept severity="minor" id="osgi-bundle:ImportPackage">
    <requiresConcept refId="osgi-bundle:Bundle"></requiresConcept>
    <description>Creates an IMPORTS relation from a bundle artifact to all packages which are declared as
            "Import-Package" in the bundle manifest.
        </description>
    <cypher><![CDATA[
            match
             (package:Package)
            with
              package, "(^|.*,)\\s*"+ replace(package.fqn, ".", "\\.")+"\\s*((;|,).*|$)" as pattern
            match
              (bundle:Osgi:Bundle)-[:CONTAINS]->(manifest:File:Manifest),
              (manifest)-[:DECLARES]->(section:ManifestSection),
              (section)-[:HAS]->(entry:ManifestEntry)
            where
              entry.name = "Import-Package"
              and entry.value =~ pattern
            create unique
              (bundle)-[:IMPORTS]->(package)
            return
              bundle as Bundle, collect(package) as ImportedPackages
        ]]></cypher>
  </concept>
  <concept severity="minor" id="osgi-bundle:InternalType">
    <requiresConcept refId="osgi-bundle:ExportPackage"></requiresConcept>
    <description>Labels all internal types (i.e. which are not located in an exported package) as "Internal".
        </description>
    <cypher><![CDATA[
            match
              (bundle:Bundle:Osgi)-[:CONTAINS]->(internalPackage:Package),
              (bundle)-[:CONTAINS]->(internalType:Type),
              (internalPackage)-[:CONTAINS]->(internalType:Type)
            where not
                (bundle)-[:EXPORTS]->(internalPackage)
            set
              internalType:Internal
            return bundle as Bundle, collect(internalType) as InternalTypes
        ]]></cypher>
  </concept>
  <concept severity="minor" id="testng:AfterClassMethod">
    <description>Labels all methods annotated by "@org.testng.annotations.AfterClass" with "TestNG" and "AfterClassMethod".</description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method),
              (m:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.testng.annotations.AfterClass"
            SET
              m:TestNG:AfterClassMethod
            RETURN
              m AS AfterClassMethod, c AS TestClass

        ]]></cypher>
  </concept>
  <concept severity="minor" id="testng:AfterMethod">
    <description>Labels all methods annotated by "@org.testng.annotations.AfterMethod" with "TestNG" and "AfterMethod".
        </description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method),
              (m:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.testng.annotations.AfterMethod"
            SET
              m:TestNG:AfterMethod
            RETURN
              m AS AfterMethod, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="testng:AfterTestMethod">
    <description>Labels all methods annotated by "@org.testng.annotations.AfterTest" with "TestNG" and "AfterTestMethod".
        </description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method),
              (m:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.testng.annotations.AfterTest"
            SET
              m:TestNG:AfterTestMethod
            RETURN
              m AS AfterTestMethod, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="testng:BeforeClassMethod">
    <description>Labels all methods annotated by "@org.testng.annotations.BeforeClass" with "TestNG" and "BeforeClassMethod".</description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method),
              (m:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.testng.annotations.BeforeClass"
            SET
              m:TestNG:BeforeClassMethod
            RETURN
              m AS BeforeClassMethod, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="testng:BeforeMethod">
    <description>Labels all methods annotated by "@org.testng.annotations.BeforeMethod" with "TestNG" and "BeforeMethod".</description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method),
              (m:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.testng.annotations.BeforeMethod"
            SET
              m:TestNG:BeforeMethod
            RETURN
              m AS BeforeMethod, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="testng:BeforeTestMethod">
    <description>Labels all methods annotated by "@org.testng.annotations.BeforeTest" with "TestNG" and "BeforeTestMethod".</description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method),
              (m:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.testng.annotations.BeforeTest"
            SET
              m:TestNG:BeforeTestMethod
            RETURN
              m AS BeforeTestMethod, c AS TestClass
        ]]></cypher>
  </concept>
  <concept severity="minor" id="testng:TestClass">
    <requiresConcept refId="testng:TestMethod"></requiresConcept>
    <description>Labels all classes containing test methods with "Test" and "TestNG".</description>
    <cypher><![CDATA[
            MATCH
              (c:Type:Class)-[:DECLARES]->(m:Method:TestNG:Test)
            SET
              c:Test:TestNG
            RETURN
              c AS TestClass, COLLECT(m) AS TestMethods
        ]]></cypher>
  </concept>
  <concept severity="minor" id="testng:TestMethod">
    <description>Finds all test methods (i.e. annotated with "@org.testng.annotations.Test") and labels them with "Test" and
            "TestNG".
        </description>
    <cypher><![CDATA[
            MATCH
              (m:Method)-[:ANNOTATED_BY]-()-[:OF_TYPE]->(a:Type)
            WHERE
              a.fqn="org.testng.annotations.Test"
            SET
              m:Test:TestNG
            RETURN
              m AS Test
        ]]></cypher>
  </concept>
  <constraint severity="info" id="cdi:BeansMustNotUseFieldInjection">
    <requiresConcept refId="cdi:InjectionPoint"></requiresConcept>
    <description>CDI beans shall not use field injection (constructor and setter injections are fine.).</description>
    <cypher><![CDATA[
            MATCH
              (a:Type)-[:DECLARES]->(member:Field:Cdi:InjectionPoint)
            RETURN
              DISTINCT a.fqn AS invalidBean
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="cdi:BeansMustUseConstructorInjection">
    <requiresConcept refId="cdi:InjectionPoint"></requiresConcept>
    <description>All CDI beans must use constructor injection.</description>
    <cypher><![CDATA[
            MATCH
              (a:Type)-[:DECLARES]->(member:Cdi:InjectionPoint)
            WHERE
              NOT member:Constructor
            RETURN
              DISTINCT a.fqn AS invalidBean
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="dependency:ArtifactCycles">
    <requiresConcept refId="dependency:Artifact"></requiresConcept>
    <description>There must be no cyclic artifact dependencies.</description>
    <cypher><![CDATA[
            MATCH
                (a1:Artifact)-[:DEPENDS_ON]->(a2:Artifact),
                path=shortestPath((a2)-[:DEPENDS_ON*]->(a1))
            WHERE
                a1<>a2
            RETURN
                a1 AS Artifact, EXTRACT(a IN nodes(path) | a.fqn) AS Cycle
            ORDER BY
                Artifact.fqn
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="dependency:PackageCycles">
    <requiresConcept refId="dependency:Package"></requiresConcept>
    <description>There must be no cyclic package dependencies.</description>
    <cypher><![CDATA[
            MATCH
                (p1:Package)-[:DEPENDS_ON]->(p2:Package),
                path=shortestPath((p2)-[:DEPENDS_ON*]->(p1))
            WHERE
                p1<>p2
            RETURN
                p1 AS Package, EXTRACT(p IN nodes(path) | p.fqn) AS Cycle
            ORDER BY
                Package.fqn
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="dependency:TypeCycles">
    <requiresConcept refId="dependency:Package"></requiresConcept>
    <description>There must be no cyclic type dependencies.</description>
    <cypher><![CDATA[
            MATCH
                (p1:Package)-[:DEPENDS_ON*0..1]->(p2:Package),
                shortestPath((p2)-[:DEPENDS_ON*]->(p1))
            WITH
                p1, p2
            MATCH
                (p1)-[:CONTAINS]->(t1:Type),
                (p2)-[:CONTAINS]->(t2:Type),
                (t1)-[:DEPENDS_ON]->(t2),
                path=shortestPath((t2)-[:DEPENDS_ON*]->(t1))
            WHERE
                NOT (
                  t1 = t2 OR (t1)-[:DECLARES]-(t2)
                )
            RETURN
                LENGTH(path) AS Length, EXTRACT(p IN nodes (path) | p.fqn) AS Cycle
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="jpa2:ValidationModeMustBeExplicitlySpecified">
    <description>The validation mode of all persistence units must be explicitly specified and either set to CALLBACK or NONE.</description>
    <cypher>
            MATCH
              (pu:PersistenceUnit)
            WHERE
              not has(pu.validationMode)
              OR NOT (
                pu.validationMode='CALLBACK'
                OR pu.validationMode='NONE'
              )
            RETURN
              pu AS PersistenceUnit
        </cypher>
  </constraint>
  <constraint severity="info" id="junit4:AssertionMustProvideMessage">
    <requiresConcept refId="junit4:AssertMethod"></requiresConcept>
    <description>All assertions must provide a message.</description>
    <cypher><![CDATA[
            MATCH
              (testType:Type)-[:DECLARES]->(testMethod:Method),
              (testMethod)-[invocation:INVOKES]->(assertMethod:Assert:Method)
            WHERE
              NOT assertMethod.signature =~ 'void assert.*\\(java.lang.String,.*\\)'
            RETURN
              invocation AS Invocation,
              testType AS DeclaringType,
              testMethod AS Method
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="junit4:IgnoreWithoutMessage">
    <description>All @Ignore annotations must provide a message.</description>
    <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->(ignore:Annotation)-[:OF_TYPE]->(ignoreType:Type)
            WHERE
              ignoreType.fqn= "org.junit.Ignore"
              AND NOT (ignore)-[:HAS]->(:Value{name:"value"})
            RETURN
              e AS IgnoreWithoutMessage
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="junit4:TestMethodWithoutAssertion">
    <requiresConcept refId="junit4:AssertMethod"></requiresConcept>
    <requiresConcept refId="junit4:TestMethod"></requiresConcept>
    <description>All test methods must perform assertions (within a call hierarchy of max. 3 steps).</description>
    <cypher><![CDATA[
            MATCH
              (testType:Type)-[:DECLARES]->(testMethod:Test:Method)
            WHERE
              NOT (testMethod)-[:INVOKES*..3]->(:Method:Assert)
            RETURN
              testType AS DeclaringType,
              testMethod AS Method
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="maven3:HierarchicalParentModuleRelation">
    <description>If a parent Maven project declares a module then the parent project must also be declared as the
            parent of the module (i.e. to keep the
            project hierarchy consistent).
        </description>
    <cypher><![CDATA[
            match
              (parent:Maven:Project)-[:HAS_MODULE]->(module:Maven:Project)
            where
              not (module)-[:HAS_PARENT]->(parent)
            return
              module as InvalidModule
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="modules:ShoppingCartDependencies">
    <requiresConcept refId="modules:DefinedModules"></requiresConcept>
    <description>All types in shopping cart module must only have dependencies to the user module.</description>
    <cypher><![CDATA[
          MATCH
            (m1:Package:Module)-[:CONTAINS*0..]->(type1:Type),
            (m2:Package:Module)-[:CONTAINS*0..]->(type2:Type),
            (type1)-[:DEPENDS_ON]->(type2)
          WHERE
            m1<>m2 AND
            m1:ShoppingCart
            AND NOT (
              m2:UserManagement
          )
          RETURN
            type1.fqn as Dependent, m2.fqn as InvalidModuleDependency, type2.fqn as InvalidTypeDependency
		]]></cypher>
  </constraint>
  <constraint severity="info" id="modules:UndefinedModules">
    <requiresConcept refId="modules:DefinedModules"></requiresConcept>
    <description>All direct sub-packages of "org.jqassistant.demo" must be defined as modules.</description>
    <cypher><![CDATA[
          MATCH
            (root:Package)-[:CONTAINS]->(m:Package)
          WHERE
            root.fqn="org.jqassistant.demo"
            AND NOT (
              m:Module
            )
          RETURN
            m.fqn as UndefinedModule
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="naming:EntitiesInModelPackages">
    <requiresConcept refId="jpa2:Entity"></requiresConcept>
    <description>All JPA entities must be located in "model" packages.</description>
    <cypher><![CDATA[
          MATCH
            (p:Package)-[:CONTAINS]->(e:Jpa:Entity)
          WHERE NOT
            p.fqn =~ '.*\\.api\\.model'
          RETURN
            e.fqn as Entity
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="naming:PackageNameContainsModuleName">
    <description>Verifies that all types are located in packages containing the group (groupId) and name (artifactId) of the Maven module.</description>
    <cypher><![CDATA[
         MATCH
           (module:Maven)-[:CREATES]->(artifact:Artifact)
         WITH
           artifact, artifact.group + "\\." + artifact.name + "\\..*" as prefixPattern
         MATCH
           (artifact)-[:CONTAINS]->(type:Type)
         WHERE NOT
           type.fqn =~ prefixPattern
         RETURN
           type as TypeInInvalidPackage
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="osgi-bundle:InternalTypeMustNotBePublic">
    <requiresConcept refId="osgi-bundle:InternalType"></requiresConcept>
    <requiresConcept refId="osgi-bundle:Activator"></requiresConcept>
    <description>Internal types must not be public if no depending types exist in other packages of the bundle.
        </description>
    <cypher><![CDATA[
            match
              (bundle:Osgi:Bundle)-[:CONTAINS]->(internalType:Type:Internal),
              (internalPackage:Package)-[:CONTAINS]->(internalType)
            optional match
              (bundle)-[:CONTAINS]->(otherPackage:Package),
              (otherPackage)-[:CONTAINS]->()-[:DEPENDS_ON]->(internalType)
            where
              internalType.visibility='public'
            with
              bundle, internalPackage, internalType, collect(otherPackage) as otherPackages
            where
              all(otherPackage in otherPackages where internalPackage = otherPackage)
              and not
                (internalType)-[:ACTIVATES]->(bundle)
            return
              bundle as Bundle, internalType as InternalType
        ]]></cypher>
  </constraint>
  <constraint severity="info" id="osgi-bundle:UnusedInternalType">
    <requiresConcept refId="osgi-bundle:InternalType"></requiresConcept>
    <requiresConcept refId="osgi-bundle:Activator"></requiresConcept>
    <description>A bundle must not contain internal types which are not used by other types in the bundle.
        </description>
    <cypher><![CDATA[
            match
              (bundle:Osgi:Bundle)-[:CONTAINS]->(internalType:Type:Internal)
            where not (
                (internalType)-[:ACTIVATES]->(bundle)
              or
                (bundle)-[:CONTAINS]->(:Type)-[:DEPENDS_ON]->(internalType)
            )
            return
              bundle as Bundle, internalType as InternalType
        ]]></cypher>
  </constraint>
</ns2:jqassistant-rules>